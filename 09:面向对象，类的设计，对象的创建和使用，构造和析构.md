## 面向对象

### 1.面向对象的设计思想/面向过程的设计思想

面向对象/面向过程是一种编程思想

面向对象变成：Object Oriented Pragramming -->简称OOP

​	面向对象变成把对象当做程序的单元。

​	一个对象包含了对应的数据和操作数据的方法

在python中 所有的数据类型都可以视作对象，也可以自定义对象【python提供的内置方法，自定义方法】

面向对象与面向过程的区别：

1.面向过程的编程思想：

​	解决过程的时候，分析出解决问题的所有步骤，然后通过函数将这些步骤一个一个的实现，最后完成功能的时候一个函数一个函数的调用即可

2.面向对象的编程思想：

​	把构成问题的事物分成各个对象，然后建立对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为

面向对象编程的缺点：

​	可控性差，无法向面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果，面向对象的程序一旦开始就由对象之间的交互解决问题，即便是上帝也无法预测最终结果。

### 2.面向对象中的类与对象的概念

创建对象的时候要有对应的对象类型才可以

​	list -->python提供的

自定义对象 --->在程序中声明对应的类型

#### 类和对象的概念：

​	类：是一类事物的描述，是对象的抽象描述

​	对象：是一类事物中存在的实体

### 3.类的设计

设计类的关键字：**class**

​			自定义类名 需要遵守标识符规范 并且符合**大驼峰命名规范**：每个单词的首字母大写

​	注意：

​		在类体中出现的只有**变量和方法**		

类的相关方法：

```python
#类的相关方法(定义一个类,也会产生自己的名称空间)
类名.__name__   # 类的名字(字符串)
类名.__doc__    # 类的文档字符串
类名.__base__   # 类的第一个父类(在讲继承时会讲)
类名.__bases__  # 类所有父类构成的元组(在讲继承时会讲)
类名.__dict__   # 类的字典属性、名称空间,找到类中所有的属性和方法
类名.__module__ # 类定义所在的模块
类名.__class__  # 实例对应的类(仅新式类中)
```

**命名空间的问题**:先从对象的命名空间找,随后在从类的命名空间找,随后在从父类的命名 空间找。

### 4.对象的创建与使用

**在python语言中，不管什么类型的实例都被看做对象，如整数也被作为对象看待，它属于int类**

创建对象的语法：

​	变量 = 类型()

**获取对象的特征**

​	变量.对应的特征

**对象的特征描述是动态赋予的**

​	可以随时添加的

​	---->这种情况添加 会造成类对对象的描述不统一

​	解决这种问题的方案（限制对对象随意添加属性）：

​		在类中添加**\__slots__**变量 --->这个变量的值是一个元组：用于限制类中描述对象属性特征的

```python
#__init__是用来初始化对应的实例变量的
#如果没有在类Class的最初的__init__函数中，正确的初始化实例变量，则会导致后续没有变量可用，因而出现AttributeError的错误(属性错误)

class Students:
	__slots__ = ("name","age")#使用其他的属性就会报错
	def __init__(self,name,age)
		self.name = name
		self.age = age
#在类的外面为对象添加的特征, 这种形式添加只对这个当前对象有效 于该类的其他对象无效
#tea.height = 163
```

**编写一个学生类，要求有一个计数器，统计总共实例了多少个对象**

```python
class Student(object):
    count=0
    def __init__(self,name,age):
        self.name=name
        self.age=age
        Student.count += 1  #注意没有初始化的属性需要使用类名调用

if __name__=='__main__':
    student1=Student('老李',12) #可以在创建对象的时候直接给属性赋值
    student2=Student()
    student2.name='小王'
    student2.age=12
    student2.save()
    print(Student.count) #使用的是类的属性
```



### 5.构造方法与析构方法

#### 构造方法：

```python
#注意以下几个问题：
	1.在某个类中如何使用其他类的对象
    2.在类方法中如何使用本类的属性
    3.在类方法中如何使用本类的一个对象
#定义一“圆”Cirlcle类，圆心为“点”Point类，构造一圆，求圆的周长和面积，并判断某点与圆的关系。
class Pointer(object):
    def __init__(self,x,y):
        self.x = x
        self.y = y
        
import math
from question4.pointer import Pointer
class Circle(object):
    def __init__(self,center_point,radius):
        self.center_point = center_point
        self.radius = radius

    def area(self):
        return math.pi * self.radius ** 2

    def circumference(self):
        return math.pi * self.radius * 2

    def relation(self,other_point):
        r = (self.center_point.x - other_point.x) ** 2 + (self.center_point.y - other_point.y) ** 2
        if r > self.radius ** 2:
            return("该点在圆外")
        elif r < self.radius ** 2:
            return ("该点在圆内")
        else:
            return("该点在圆上")
       
from question4.pointer import Pointer
from question4.circle import Circle
def main():
    a = Pointer(4, 7)
    circle1 = Circle(a, 4)
    other_point1 = Pointer(2, 5)
    print(circle1.area())
    print(circle1.circumference())
    print(circle1.relation(other_point1))

if __name__ == "__main__":
    main()
```

#### 析构方法：

​	对象被销毁的时候调用的方法

```python
class Person:
    #初始化方法 ---> 构造方法
    def __init__(self, name, age):
        self.name = name
        self.age = age

    #析构方法
    #当对象被销毁的时候（对象的引用指向为0的时候，可以将指向移走或者删除变量达到对象被销毁的目的）
    def __del__(self):
        print("析构方法被执行了", self)
        #某个对象销毁之后需要执行的功能 需在析构方法中添加才可以
析构函数： 

“__del__”就是一个析构函数了，当使用del 删除对象时，会调用他本身的析构函数，另外当对象在某个作用域中调用完毕，在跳出其作用域的同时析构函数也会被调用一次，这样可以用来释放内存空间。

__del__()也是可选的，如果不提供，则Python 会在后台提供默认析构函数

如果要显式的调用析构函数，可以使用del关键字，方式如下：
del对象名
 
 
垃圾回收机制
Python 采用垃圾回收机制来清理不再使用的对象；Python 提供gc模块释放
不再使用的对象，Python 采用‘引用计数’ 的算法方式来处理回收，
即：当某个对象在其作用域内不再被其他对象引用的时候，Python 就自动清除对象；
Python 的函数collect()可以一次性收集所有待处理的对象(gc.collect())
#当对象不再被使用时，__del__方法运行，但是很难保证这个方法究竟在 什么时候 运行。如果你想要指明它的运行，你就得使用del语句
```

