```python
#打印：男演员胡歌和女演员刘涛主演琅琊榜
class Tv:
	def __init__(self,name):
	self.name = name
class Actor:
	def __init__(self,name,sex):
		self.name = name
		self.sex = sex
	def play(self,other_actor,tv)
		print(self.sex,"演员",self.name,"和",other_actor.sex,"演员",other_actor.name,"参演",tv.name)
	
	from ……  import……
	def main():
	actor1 = Actor("胡歌","男")
	actor2 = Actor("刘涛","女")
	tv =Tv("琅琊榜")
	actor1.play(actor2,tv)
if __name__ == "__main__"
	main()
```

```python
def get_ch_count(str1):
    #生成一个列表 ---> 存放没有重复的字符
    single = []
    #遍历字符串 向列表中添加字符
    for s in str1:
        if s not in single:
            single.append(s)
    #或者
    single=list(set(str1))

    #根据每个字符获得对应字符在字符串中个数
    counts = []
    for s in single:
        count = str1.count(s)
        counts.append(count)
    #列表中的最大值
    max_count = max(counts)

    #获取counts中重复的最大数据 对应的索引
    indexes = []

    #遍历counts列表 去与max_count
    for i in range(len(counts)):
        if counts[i] == max_count:
            indexes.append(i)

    #生成一个字典 接收最后的结果
    res_dict = {}

    for index in indexes:
        res_dict[single[index]] = counts[index]

    return res_dict

print(get_ch_count("abecmepdcdefgeabcabc"))
```

## 一、面向对象的语言的三大特点：封装，继承，多态

### 1.封装特性

1.1什么是封装

封装分为两种形态： 一种是广义的，一种是狭义的

广义的封装类似于函数的封装：将一个功能单独提取出来，进而封装成函数，如果需要该功能，直接调用即可。

狭义的封装：对具体对象的一个抽象，即将某些需要隐藏的部分进行隐藏，外界不可见，需要对外界提供可以操作隐藏内容的接口（方法）

​	在代码中的体现形式：就是**将对象特征属性进行私有化**[这些特征只能在当前类中]，**对外开放操作对象特征属性的方法**，[提供获取属性的值的方法，和修改属性值的方法]

1.2为什么要进行封装

​	保护隐私，隔离复杂度

​	在特征属性前加双下划线可以隐藏属性，外界没有办法直接获取

​	想让外界获取私有化的内容 ，需要提供操作的方式

外界需要访问的形式有两种：

​	1.一个是赋值

​		set_属性名

​		赋值的方法需要有一个形参：接受外界赋予的新值

​		但是没有return语句

​	2.一个是获取值

​		get_属性名

​		外界单纯的想获取属性的值 没有进行传值的操作

​			没有形参  但是有return语句

```python
class Person:
  def __init__(self,name,age)
  	self.name = name 
    #self.__age = age#将属性隐藏起来
    self.set_age(age)
    
def set_age(self,age):#set访问的方式
  	if age > 0:
	self.__age = age
	else:
      	print("人的年龄没有负数的情况")
        self.__age = 1#不满足需求的话给属性一个默认值
        
def get_age(self):#get访问的方式
  #赋值的时候进行判断，导致person没有__age这个属性
  #然而就直接使用了
	return self.__age
  
from …… import……
def main():
  	per = Person("dawang",-12)
	age = per.get_age()#获取值
	print(age)

	per.set_age(20)#赋值
	print(per.get_age)	
 if __name__ == "__main__":
  	main()
    
   def __init__(self,breed,age,sex):
        self.breed = breed
        self.age = age
        self.sex = sex
    @property
    def breed(self):
        return self.__breed

    @breed.setter
    def breed(self,breed):
        self.__breed = breed

    
    def behavior(self):
        print(self.breed,"在吼叫" )
        
from animal.animals import Animal
class Tiger(Animal):
    def __init__(self,breed,age,sex):
        super().__init__(breed,age,sex)#子类调用父类的特征属性

    def behavior(self):
        super().behavior()     #调用父类的行为
        print(self.breed,"嗷嗷的吼叫")            
```

几种变量的声明格式：

​	age -->这种设置属性变量的方式是公共的

​	_age--->受保护的 访问形式与age是一样的

​	__age--->私有化 访问只能在当前类中进行访问

```
__age__ --->系统的内置变量 #不建议自定义的时候使用
		__name__
		__all__
		__slots__    #保护类得对象的特征属性的个数不变
```

**在python中没有真正的私有化，一切全靠自觉**

```
__age并不是真正的私有化 外界还可以获取
	当将变量设置为__age的时候 解释器会将  _Person__age（_类__特征属性）
```

### 2.@property装饰器

修饰get方法的-->作用是将get方法属性化

​	属性：

​		外界获取name的值

​		name = person.get_name

```python
1.@property的作用:
    将get方法属性化
    调用get方法的时候 不用加()来调用了 可以直接类似于属性那种形式调用
2.将set方法属性化的装饰器是由get方法的装饰器创建出来的
	@get方法的方法名.setter
    
3.在__init__方法中，
	self.name=name
    self.age=age
    
4.set方法对私有化属性赋值,没有return
  get方法return私有化属性的值
    
5.属性化的方法名不用使用get_age或set_age，直接使用age

6.在对象调用属性化的方法时，不需要()



#get 方法属性化
@property
def age(self):
	return self.__age

#@get方法的方法名.setter
@age.setter  #set  #方法属性化
def age(self,age):
	self.__age = age

#那么__init__初始化属性的时候也要改变

class Person:
    def __init__(self,name,age,sex):
        self.name = name
        self.age = age
        self.sex = sex
    @property
    def sex(self):
        return self.__sex
    @sex.setter
    def sex(self,sex):
        self.__sex = sex

def main():
    person1 = Person("大熊",14,"男")
    a = person1.sex   #获取sex的值
    print(a)
    person1.sex = "女" #对sex进行赋值 <------重要！！！
    print(person1.sex)
if __name__ == "__main__":
    main()

```

### 3.继承

程序中的继承

​	从相关的两个或者两个以上的普通类中 提取共性 放置在一个共通类中，通过一种关联 关联普通类

格式：

​	class 父类：

​		子类共通的特征

​		子类共同的行为

​	class 子类类名(父类1，父类2...)

​		子类共通的特征

​		子类共同的行为

python中有一个根类Object，它是所有类的直接或者间接地父类 

python继承的特点：

​	多继承

​	但是一般写的时候都写单继承

​	单继承：

​		一个子类有且仅有一个直接父类

​	多继承

​		一个子类可以有多个直接父类

​	从上往下走是一种**派生**关系

​	从下往上走是一种**继承**关系

#### 3.1继承过程中对象属性特征的使用

**如果是子类可见的属性[也就是父类没有私有化]子类可以直接使用**

```python
如何将值传递给父类的init方法
#方式1：super（当前类，self).__init__(值传递过去)
super(Student,self).__init__(name,age,sex)
#方式2：父类类名.__init__(值传递过去)
这种形式是通过类名调用的，在__init__方法中不知道要给哪个对象赋值，需要将对应的对象进行值传递
Person.__init__(self,name,age,sex)
self.sid = sid
#方式3：super().__init__(值传递)
self.sid = sid 
```

3.1继承过程中对象属性特征的使用

**如果是不可见的属性-->父类会提供对应的操作方法（set和get方法）**

#### 3.2继承过程中方法的使用

可以直接使用父类中的方法：**就像直接使用自己的一样**

如果父类提升的方法某个子类而言，功能不完善，**子类可以重写父类中的方法**，完善自己的需求

重写的重点：

​	1. 子类中的方法声明与父类中的方法声明一致

​	2. 当子类重写了父类的方法之后，子类调用该方法是 调用的子类重写的，父类的就被覆盖了。

​	3. 既执行父类的又执行子类重写的方法：使用super调用，再加上自己的重写的方法，两者可以共存

3.2.1方法的重写 

系统方法重写 和自定义方法重写

```python
__str__
	面向用户的，以自定义的一种字符串格式向用户展示对象的内容
	如果不重写，默认展示的是对象的地址信息
	
	class Person: #继承自object
    def __init__(self, name, age):
        self.name = name
        self.age = age

    #想以自定义的形式向用户展示对象的信息的 ---> 重写str方法
    def __str__(self):
        return "[Person name:%s, age:%d]" % (self.name, self.age)
__repr__
	面向程序的 以自定义的一种字符串格式向解释器展示对象的内容
	如果不重写，默认展示的是对象的地址信息

__ str__ = __repr__ #由于一些情况下 repr的内容 与 str的内容展示情况一致可以运行函数是值的思想来进行数据赋值
	
#如果没有重写__str__ 面向用户的时候 会去执行__repr__
```

### 4.多态

多态意思是“有多种形式”。多态意味着就算不知道变量所引用的对象类是什么，还是能对它进行操作，而它也会根据对象（或类）类型的不同而表现出不同的行为。

```python
>>>1 + 2 
3
>>>'fish' + 'license'
'fishlicense'
def add(x,y):
    return x + y
>>>add(1,2)
>>>add('hello','world')
#还比如len函数，不论是什么类型的数据，都可以使用len函数来获取其长度
```

多态就是多种形态：子类继承父类，然后子类能够复写父类的方法，子类可以调用该方法实现自己的需求，这样的好处是，**一个方法在不同的子类中就有不同的作用**。