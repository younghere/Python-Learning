## 一、类属性

```python
#对象属性 在 __init__这个方法中声明出来的 它是由对象来调用的 它是属于每一个对象的

#类属性 直接声明在类体中的 跟其他的方法是平级的 是属于类的 -->被该类的所有对象所共享的
	#当该类的所有对象 对应的某一个属性值一致时，可以将该属性声明成类属性
 建议：
	之后使用的时候 通过类名来调用 虽然可以通过对象来调用 但是建议通过类名来调用
#注意：
	1.子类调用父类的类属性 super().__init__(父类属性1,父类属性2..)
    2.子类重写父类类方法时调用父类的类方法 super(父类类名,self).父类方法()
	3.在类中直接创建对象：
    4.类中的属性包括：类属性和实例属性(类和类的实例化对象都可以调用这两种属性
    5.如果在类外修改类属性，必须通过类对象去引用然后进行修改。如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，不会影响到类属性，并且如果通过实例对象引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性   
    
class Foo:
    count = 0 # 用来计数
    ids = [] # 存储所有已经创建对象的id
     
    def __init__(self):
        Foo.count += 1
        Foo.ids.append(id(self))
  #删除数据       
    def __del__(self):
        Foo.count -= 1
        for i in range(len(Foo.ids)):
            if id(self) == Foo.ids[i]:
                del Foo.ids[i]
                break
         
a = Foo()
b = Foo()
print Foo.count
del a
print Foo.count


#记录每个对象的数据
class Student:
    count = 0
    iddict = {}
    def __init__(self,name,sid):
        self.name = name
        self.sid = sid
        Student.count += 1#记录对象实例的个数
        Student.iddict[self.name] = self.sid#记录对象实例的数据
    def get_count(self):
        return self.count
    def get_dict(self):
        return self.iddict
      
from new.student import Student
def main():
    student1 = Student("小李",24)
    student2 = Student("小王",27)
    student3 = Student("校长",34)
    print(student1.count)
    print(student3.iddict)
if __name__ == "__main__":
    main()
    
#子类调用父类的行为属性：
#父类中行为属性vioce()私有化
class Animal(object):
    def __init__(self, spiece, age, sex):
        self.set_spiece(spiece)
        self.set_age(age)
        self.set_sex(sex)
     def voice(self):
        print(self.__spiece,"的叫声")#行为属性vioce()私有化

class Dog:       
     def voice(self):
        super().voice()   #子类中vioce调用父类的行为属性
        print("咕咕的")
        
        
class Person(object):
    # def __init__(self, name, age, country):
    #     self.name = name
    #     self.age = age
        #self.country = country

    country = "CH"      #直接在类下定义函数，对类的所有对象都有作用
    def __init__(self, name, age):
        self.name = name
        self.age = age
p1 = Person("陈强", 22)
print(p1.country)#调用country的方法
```

## 二、类方法和静态方法

**对象方法**---->通过对象来调用的

​	对象方法有一个参数self -->不用传值 使用对象调用时，默认将当前对象赋予该参数

**类方法和静态方法**：

​	1.**类方法**：

​		是类对象所拥有的方法，**需要用修饰器`@classmethod`来标识其为类方法**，对于类方法，**第一个参数必须是类对象，一般以`cls`作为第一个参数**（当然可以用其他名称的变量作为其第一个参数，但是大部分人都习惯以'cls'作为第一个参数的名字，就最好用'cls'了），能够通过实例对象和类对象去访问

```python
class People(object):
    country="china"
 
    @classmethod
    def getCountry(cls):
        return cls.country
p=people()
print(p.getCountry())   #实例对象调用类方法
print(People.getCountry())  #类对象调用类方法
```

​	类方法还有一个用途就是**可以对类属性进行修改**：

```python
class people:
    country="china"
 
    @classmethod
    def getCountry(cls):
        return cls.country
    @classmethod
    def setCountry(cls,country):
        cls.country=country
 
p.setCountry("Japan") 	#使用类方法来修改类属性
 
print(p.getCountry())#使用对象来调用类方法效率比较低，因为对象方法调用需要先确定类是否正确 在通过对象调用，比较繁杂
print(people.getCountry())#一般通过类来调用类方法

```

​	2.**静态方法:**

​		需要通过修饰器`@staticmethod`来进行修饰，**静态方法不需要多定义参数**,因此在静态方法中引用类属性的话，**必须通过类对象来引用**

```python
class People:
    country="china"
 
    @staticmethod
    def getCountry():
        return People.country
p=People()
print(p.getCountry())   #实例对象调用类方法
print(People.getCountry())  #类对象调用类方法，一般通过类来调用类方法
```



​	用类的时候

​	注意：

​		在该方法中不能使用self

​	原因：classmethod修饰的方式是属于类的 self表示的是当前的对象

如果想使用一个内容 首先这个内容必须在内存中存在才可以使用

​			***当类方法被调用的时候  这个时候还没有对象, 所以没有办法使用对象相关的内容***

​		简单来说: **类方法的加载时机 要比对象早**	

```python
#使用类的时候,加载流程:
			使用类的时候 ---> 
					1. 将类加载到 方法区中
						随着类加载的有类属性 和 类方法 [类方法的内容已经在内存中存在着]
					2. 新建对象 将对象在堆中开辟空间
						将对象对应的属性跟随者加载堆中 为属性进行初始化 __init__
					3.将对象的首地址 赋给栈中的 变量
					
			方法执行是在  方法区中拷贝一份到栈中执行的, 执行完成之后 拷贝这一份就释放了

```

**了解类、方法、属性调用的流程**

## 三、发送邮件

发送纯文本

发送带有附件的邮件

​	发送邮件需要的协议：smtp(简单邮件传输协议)(Simple Mail Transfer Protocol)

邮件发送的流程：

​	邮件发送的时候 是通过smtp协议将邮件发送到邮件服务器  服务器根据接受者的协议  将邮件返回给收件者

```python
#coding:utf-8
#先导入smtp协议对应的模块
import smtplib
#邮件下面模块的内容  发送文本
from email.mime.text import MIMEText

#简单的准备工作:
#服务器地址
#server_add = "smtp.163.com"
server_add = "smtp.qq.com"
#发送者账号 也是登录邮箱的账号
#user_email = "15650726528@163.com"
user_email = "1114354656@qq.com"
#授权密码
#psw_email = "a123456"
psw_email = "ejmvqxqmlwbojahe"

#接收者
reveives = ["1114354656@qq.com", "1322649220@qq.com", "cjx210050@163.com"]

#主题
title = "人生苦短, 及时享乐"
#内容
content = "hehehahaxiximeimei"

#设置发送文本
message = MIMEText(content, "plain", "utf-8")
#设置信息发送者
message["From"] = user_email
#接收者
message["To"] = ",".join(reveives)
#设置主题
message["Subject"] = title

#连接服务器 发送信息
smtpobj = smtplib.SMTP(server_add, 25)
#登录验证
smtpobj.login(user_email, psw_email)
#发送信息
smtpobj.sendmail(user_email, reveives, message.as_string())
print("send success")

#可以传附件的电子邮件
#coding:utf-8
import smtplib
from email.mime.text import MIMEText
#内容是拼接在一起的 ---> 拼接发送的内容[文本 又有附件]
from email.mime.multipart import MIMEMultipart
#设置附件的
from email.mime.application import MIMEApplication

#简单的准备工作:
#服务器地址
server_add = "smtp.163.com"
#发送者账号 也是登录邮箱的账号
user_email = "15650726528@163.com"

#授权密码
psw_email = "a123456"

#接收者
reveives = ["1114354656@qq.com", "1322649220@qq.com", "cjx210050@163.com"]

#将内容设置为多个部分
msg = MIMEMultipart()
msg["Subject"] = "Python test"
msg["From"] = user_email
msg["To"] = ",".join(reveives)

#设置发送的文本
text = MIMEText("I am very beautiful")
#发送的文本 拼接在内容上
msg.attach(text)

#设置发送的附件
#添加附件
'''
发送的是文件数据  而非文件本身
读取文件中的数据
open("文件路径", "rb").read() ---> 读取文件中的数据
'''
part = MIMEApplication(open(r"test.png", "rb").read())
#设置附件的头部信息
part.add_header('content-disposition', 'attachment', filename='test.png')
msg.attach(part)
'''
给QQ好友发文件
    QQ 上的文件名 ---> 你给发送过去的
'''

#发送
smtpobj = smtplib.SMTP_SSL(server_add, 465)
#登录
smtpobj.login(user_email, psw_email)
#发送
smtpobj.sendmail(user_email, reveives, msg.as_string())

print("发送成功")


```

## 四、面向对象的综合练习：银行的操作系统

```python
class Student(object):
    def __init__(self, name, age, sid, score):
        self.name = name
        self.age = age
        self.sid = sid
        self.score = score

    def __str__(self):
        return "[Student name:%s-age:%d-sid:%s-score:%d]" % (self.name, self.age, self.sid, self.score)

    __repr__ = __str__
    
class Class(object):
    def __init__(self, name):
        self.name = name
        self.studnets = []


    #添加学生
    def add_stu(self, *stus):
        for stu in stus:
            self.studnets.append(stu)

    #根据学号查找学生
    def search_stu(self, sid):
        for s in self.studnets:
            if s.sid == sid:
                return s
        return None #表示没有找到

    #根据学号删除学生对象
    def del_stu(self, sid):
        #根据学号进行查找
        stu = self.search_stu(sid)
        if stu != None:
            self.studnets.remove(stu)

    #排序 根据学号升序排序
    def sort_sid(self):
        for out in range(1, len(self.studnets)):
            for innner in range(out, 0, -1):
                if self.studnets[innner].sid < self.studnets[innner - 1].sid:
                    #交换位置
                    self.studnets[innner], self.studnets[innner - 1] = self.studnets[innner -1], self.studnets[innner]
                else:
                    break


    #排序 成绩降序
    def sort_score(self):
        self.studnets.sort(key=lambda s : s.score, reverse=True)

    #显示所有的学生
    def show_all(self):
        print(self.studnets)
        
def main():
    c0 = Class("python1805")

    #添加学生
    students = []
    names = ["朱文康", "陈家旭", "李晓波", "王月鑫", "姚广鑫"]
    ages = [20, 21, 20, 22, 24]
    sids = ["1101", "1105", "1103", "1102", "1104"]
    scores = [78, 96, 66, 72, 88]

    #遍历数组脚标
    for i in range(len(names)):
        stu = Student(names[i], ages[i], sids[i], scores[i])
        students.append(stu)

    c0.add_stu(*students)
    c0.show_all()

    #排序
    c0.sort_sid()
    c0.show_all()

    c0.sort_score()
    c0.show_all()

    #删除
    c0.del_stu("1101")
    c0.show_all()

if __name__ == "__main__":
    main()
```

卡类:

	卡号
	密码
	金额
	是否锁卡 ---> False
用户类:
	名字
	身份证号
	好多卡
管理员类
	登录页面 ---> 打印出来的
	账号
	密码
	欢迎页面 ----> 打印出来的
	操作页面 ----> 打印出来提示用户对应的操作
		1.开户
		2.查询
		3.转账
		4.取款
		5.存款
		6.修改密码
		7.锁卡
		8.解卡
		9.销户
		0.退出
操作类:
		1.开户
		2.查询
		3.转账
		4.取款
		5.存款
		6.修改密码
		7.锁卡
		8.解卡
		9.销户
		0.退出

## 五、lambda 匿名函数

1.无参匿名函数：

```python
t=lambda:True#分号前无任何参数   ====>    def func():return True
t()
```

2.带参数的匿名函数：

```python
lambda x:x**3 #一个参数
lambda x,y,z:x+y+z #多个参数
lambda x,y=3:x*y #允许参数存在默认值
```

3.匿名函数的调用

- 直接赋值给一个变量，然后再像一般函数一样调用

````python
>>>c=lamba x,y,z:x*y*z
>>> c(2,3,4)
12

>>>a=lambda *z:z #*z返回的是一个元组
>>> a('Testing1','Testing2')
('Testing1', 'Testing2')

>>> c = lambda **Arg: Arg #arg返回的是一个字典
>>> c()
{}

>>> lower = lambda x,y: x if x<y else y #求最小值

>>> a = [1,2,3,4]
>>> b = [5,6,7,8]
>>> map(lambda x,y:x+y, a,b)  #与map函数结合使用
[6, 8, 10, 12]
````

- 直接后面传递实参

  ```python
  >>> (lambda x,y: x if x> y else y)(101,102)
  102 
  
  >>> (lambda x:x**2)(3)
  9
  
  s='this is\na\ttest'
  s.split()#split函数默认分割:空格，换行符，TAB
  ''.join(s.split())
  #结果：'this is a test'
  
  #等价于：
  (lambda s:''.join(s.split()))("this is\na\ttest")
  
  >>> print (lambda x: x.startswith('B'))('Bob')
  ```