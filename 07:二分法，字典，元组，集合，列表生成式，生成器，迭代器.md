## 1.查找的算法：二分法查找

#### 前提：这个列表是有序的【排好序的】

规则：

​	劈半查找

​	起始先设定一个索引区间[0,len(list0) - 1]

​	检测这个区间的中间索引对应的元素与待查找的元素的值的大小关系

​	以升序为例：

​	待查找元素key > 中间索引mid对应的元素

​		更改区间[mid + 1,len(list0) - 1]

​		更新中间索引

​	待查找元素key < 中间索引mid对应的元素

​		更改区间[0,mid - 1]

​		更改中间索引

​	查找过程中有两种情况的出现：

​		中间索引对应的元素 == 待查找的元素

​		区间起始值 > 区间结束值 ====>  找不到了

根据查找过程中出现第一种情况来进行分析：

​	1.循环条件：中间索引对应的元素 != 待查找的元素

​	2**.**循环条件：区间合理性

```python
def index_half(search_list,key):
# 1. 设定初始区间

    min_index = 0
    max_index = len(search_list) - 1

# 2. 设定起始中间索引
    mid_index = (min_index + max_index) // 2

# 3. 进行查找
    while search_list[mid_index] != key:
        if key > search_list[mid_index]:
            # 更改区间 向后半部分查找
            min_index = mid_index + 1
        elif key < search_list[mid_index]:
            # 更改区间  向前半部分查找
            max_index = mid_index - 1

        # 更改完区间之后  判断区间是否合理
        if min_index > max_index:
            # 区间不合理
            return -1
            break
        else:
            # 区间合理  因为区间发生变化 中间索引也发生变化
            mid_index = (min_index + max_index) // 2

   else:
        # 循环条件不成立的时候才会走else
        return  mid_index
print(index())

def index2
    while min_index <= max_index:
        if key > list0[mid_index]:
                # 更改区间 向后半部分查找
            min_index = mid_index + 1
        elif key < list0[mid_index]:
            # 更改区间  向前半部分查找
            max_index = mid_index - 1
        elif key == list0[mid_index]:
            return mid_index
        else:
            # 区间合理  因为区间发生变化 中间索引也发生变化
            mid_index = (min_index + max_index) // 2
    else:
        return -1
   

def half_search(list0, x):
    min_index = 0
    max_index = len(list0) - 1
    mid_index = (min_index + max_index) // 2
    while list0[mid_index] != x:
        if min_index < max_index:
            if list0[mid_index] > x and list0[min_index] < list0[max_index]:
                max_index = mid_index - 1

            elif list0[mid_index] < x and list0[min_index] < list0[max_index]:
                min_index = mid_index + 1

            elif list0[mid_index] > x and list0[min_index] > list0[max_index]:
                min_index = mid_index + 1

            elif list0[mid_index] < x and list0[min_index] > list0[max_index]:
                max_index = mid_index - 1

            mid_index = (min_index + max_index) // 2
        else:
            return False
    else:
        return mid_index


list0 = [29, 23, 21, 5, 2]
x = 2
a = half_search(list0, x)
print(a) 
    
```

## 2.字典[dictionary]

使用键值对来进行存储的

​	key:value 具有快速的查找的速度

在字典中存放的是---对象的键值对，**键是不允许重复的**，而且要保持唯一性

因为字典的特性是**根据key来查找value的**

**能够作为key的对象必须是不可变的**，比如字符串，整数，一般常见的是字符串

字典的标识：

​		{key:value,key:value}

key不可以重复，但是value是可以重复的

### 字典有一个快速生成的方法：dict(name="laowang",age=12)



```python
dict0={"语文": 78,"数学":89}
#添加一对键值对
dict0["英语"] = 88 

#根据key获取value
value = dict0["数学"]
print(value)

#另外一种方式 ，这种形式获取如果key不存在是不会报错的，只是返回None
value = dict0.get("政治")
print value

#修改
dict0["语文"] = 99
print(dict0)

#删除 根据key删除键值对
dict0.pop("英语")
print(dict0)

#直接遍历字典 遍历的是key
for key in dict0:
  	print(key)

 #获取所有的value值
list0 = dict0.values()
print(values)

#获取所有的key值
keys = dict0.keys()
print(keys)

#获取所有的键值对
items = dict0.items()
print(items)

#遍历键值对
for key,value in dict0.items():
  print(key,":",value)
  
#使用枚举
for index,item in enumerate(dict0):
  print(index,"-",item)
  
#字典和列表的区别：
	字典：需要大量的内存，内存浪费的比较多
  		 但是查找和插入的速度特别快
    列表：占用的内存的空间是较小的
    	 查找和插入的速度回根据元素的增加会越来越慢
```



## 3.集合

类似于字典，只不过存放的是字典中的键

**不存在重复**

**元素内容是不可变的**

**无序的**【加入的顺序和显示出来的顺序是不一致的】

将其它序列转换为集合：

​	set0 = **set**("ansdfsajdflsad")

print(set0)

```python
set1 = {12,34,54,64}
#添加元素
set1.add(89)

#添加元组
set1.add((45,67))

#将列表中的元素 打碎了之后加入
set1.update([78,66,90])

#将字符串中的元素 打碎了之后加入
set1.update("asdfsjadlf")

#删除元素
set1.remove(90)

#只有元素遍历 没有索引遍历,  可以使用枚举型遍历
for ele in set1:
  print(ele)
  
enumerate()
生成的内容为：(idex,序列中的内容)

for index,element in enumerate(set1):
  print(index,"-",element)

#集合的交集
set2 = {12,34,6,75}
set3 = {12,5,34,54}
set4 = set2 & set3

#并集
set5 = set2 | set3
```

## 4.数组：

(1) list 普通的链表，初始化后可以通过特定方法动态增加元素。
定义方式：arr = [元素]

(2) Tuple 固定的数组，一旦定义后，其元素个数是不能再改变的。
定义方式：arr = (元素)

(2) Dictionary 词典类型， 即是Hash数组。
定义方式：arr = {元素k:v}



## 5.链表：

![链表](/Users/macos/Desktop/链表.png)

## 6.字典key无序的原因-哈希表

**字典的无序是指：不能人为重新排序**

哈希表是由数组和链表组成的

​	在数组中存放的是链表的节点

​		以字典为例：

​		key --->  获取哈希码--->经过函数运算--->对应数组中的索引

​				根据键值对创建链表节点---->放到对应的索引位置处

​				假设布尔类型对应的哈希码

​					Ture:0   False:1

字典的无序受两个因素影响：

​	（1）键值的哈希碰撞，hash(key1) == hash(key2)时，向字典里连续添加的这个两个键的顺序是不可以控制的，也是无法做到连续的，后来的键会按算法调整到其它位置。 

​	（2）字典空间扩容，当键的数量超过字典默认开的空间时，字典会做空间扩容，扩容后的键顺和创建顺序就会发生变化，不受人为控制					

## 5.列表生成式

```python
#新列表中元素是元列表各元素的平方
list0 =[1,5,6,8,3]
new_list = [x ** 2 for x in list0]

#可以添加if条件筛选
list1 = [1,2,3,4,5,6]
new_list1 = [x for x in list1 if x % 2 == 0]

#使用双层循环进行排列组合
list2 = ["a", "b", "c"]
list3 = ["A", "B", "C"]
#新的列表  aA  aB aC  bA bB bC  cA cB cC
new_list4 = []
for little in list2:  #a  b  c
    for upper in list3: #ABC
        new_list4.append(little+upper)
print(new_list4)
new_list5 = [low+upper for low in list2 for upper in list3]
print(new_list5)

list4 = ["Hello", "Good", "Nice", 18]
# 生成一个新的列表: 每个字符串都是小写的英文字母 ["hello", "good", "nice"]
new_list7 = [s.lower() for s in list4 if isinstance(s, str)] #非字符没有lower()方法，会报错

import os 
[d for d in os.listdir('.')]#os.listdir可以列出文件和目录

检测一个元素的类型：type
isinstance(变量，类型)如果类型匹配，返回True，否则返回False

#字典生成式
dict0 = {'a': 0,'b':1,'c':2}
#实现key与value转换
new_dict = {}
for k, v in dict0.items():
    new_dict[v] = k

#字典生成式
new_dict1 = {v:k for k, v in dict0.items()}

[k + '=' + v for k,v in dict0.items()]
```

## 6.生成器

生成器的出现是来:

​	1.避免快速生成一批数据,造成瞬间占用内存过大

​	2.如果我们仅仅需要访问前面几个元素，后面绝大部分占用空间都被浪费，避免内存空间浪费

这种一边循环一边计算的机制，称为生成器（Generator）

使用方式： 当你需要数据的时候 去找生成器去拿 才会在内存中开辟空间

生成方式：

1.将列表生成式的**中括号**换成**小括号** 就形成了一个生成器

生成器可以用next来一个个的遍历，也可以使用forin来快速遍历

```python
#使用列表生成式生成1-200的列表
list0 = [x for x in range(1, 201)]
print(list0)
#生成器
g = (x for x in range(200))
print(g)

#用next获取数据的方法
list0 = [1,2,3,4,5]
n= (x ** 2 for x in list0)

value = next(n)#列出第一个元素

value=n.next() #继续下一个

value = next(n) #继续下一个

#通过对生成器进行遍历来获取数据
for x in new_list:
    print(x）
    
#生成器中的数据只能拿一次

#当生成器中已经没有数据了 再next去拿 就会抛出StopIteration的错误

#获取指定个数的数据
def get_value(num):
    for i in range(num):
        yield i  # 把数据返回去
        #print(i)  # 当下一次在获取的时候执行这里
#这里，最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。
g1 = get_value(10)
print(g1) # <generator
#可以forin 遍历拿 也可以next一个一个的获取
#获取的流程
value = next(g1)
print("刚刚获得value:", value)

```

## 7.迭代器

可迭代对象

迭代：可以理解为另外一种遍历

**Iterable**（**可迭代对象有一个特点：可以通过next来获取下一个数据**

**使用forin可以进行遍历的类型都是可迭代类型的** ）：

​	str list dict tuple set 生成器

1. **使用迭代器需要导入模块**

		导入的是 collections模块的内容

		from collections import Iterable

2. Iterable 只是验证对应类型的对象是否可以进行迭代遍历

​     **isinstance(对象,Iterator)**

3. 将某个对象变为可迭代对象：

		iter(对象)

将那些不可以使用next获取对象的类型 转化为可以通过next来进行获取的迭代器对象

```python
#转化方式iter()
print(isinstance(iter("abc"), Iterator)) #True

list0 = [12, 45, 78, 108, 29]
for i in list0:
    print(i)
print("=======")
ite = iter(list0)
#就可以通过next来获取元素
ele = next(ite)
print(ele)

ele = next(ite)  #element元素缩写
print(ele)
```

**迭代器遍历与forin遍历的区别：**

**forin ----直接全部获取**

**迭代器：惰性遍历---不获取不返回数据**

## 8.包与模块

一个py文件就是一个模块

**修改模块的名字**：

​	import 	random	 as	 rd     修改后只能使用别名


给内容其别名

​	from  radom  import  randint  as  ri

```python
from random import * 必须在指定模块的__all__字段体现出来
这个字段是一个列表  包含的是该模块对外开放的方法 类  字段
```

**from  模块  import  ***

**相当于导入模块--all-- 中所有的内容**

**三方模块**

​	**控制台上的安装语句：  pip  install  模块名**

工作中常用到的三方模块：

​	数据库的三方模块：pymysql  / pymongo

​	数据分析： numpy

​	pygame -->帮助了解面向对象的概念 做小游戏的  但是不常用

安装完成之后像引入普通模块一样导入

包---->

1.对模块进行分类管理

2.为模块提供了更多的命名空间

------>简单的理解成目录

在程序中创建包的时候：

​	包下面--init--.py文件--->作用是程序中一个包

使用的时候      **包名.模块名**

多级包的话：  一级包名.二级包名…… n级包名.模块名

​			包名.模块名.方法名



​	

​	







**