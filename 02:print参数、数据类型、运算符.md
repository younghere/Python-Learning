## 一.听写

> 1.进制转化
>
> ​	将下列二进制数据转化为八进制数据
>
> ​			0b 010   110   111
>
> ​				2      6     7 -----> 0o267
>
> ​	将下列二进制数据转化为十进制数据
>
> ​			0b1011010
>
> ​			按权展开
>
> ​				0 * 2^0  + 1 * 2 ^ 1 + 0 * 2^2 + 1 *2^3 + 1 * 2^4 + 0 * 2 ^5 + 1 * 2 ^6 ---> 
>
> ​					0 + 2 + 0 + 8 + 16 + 0 + 64
>
> ​			8421计算法
>
> ​				2 + 8 + 16 + 64 ---> 90
>
> ​	将下列十进制数据转化为二进制数据
>
> ​			172
>
> ​			除以2取余数 倒序取余数
>
> ​			128  +  32 + 8 + 4 
>
> ​			10101100			
>
> 2. 补码运算[以八位为例]  1字节  在内存中开辟空间 最小的单位是一个字节
>
>    ​	-12 + 56
>
>    ​	18 + (-72)
>
>    正数: 原码  反码 补码是一样的
>
>    负数:
>
>    ​	原码: 在正数的原码的基础上将最高位置为1  其余位不变
>
>    ​	反码: 在负数原码的基础上除了最高位 其余位按位取反
>
>    ​	补码: 在负数反码的基础上+1
>
>    -12 + 56
>
>    -12的补码:
>
>    ​	12:    0000 1100
>
>    ​	-12 : 1000 1100
>
>    ​		1111 0011
>
>    ​		1111 0100
>
>    ​	56:   0011 1000
>
>    -----
>
>    ​       	1            0010 1100 ----> 32 + 8 + 4 = 44
>
>    18 + (-72)
>
>    ​	18:  0001 0010
>
>    ​	72: 0100 1000
>
>    ​	-72: 1100 1000
>
>    ​		1011 0111
>
>    ​		1011 1000
>
>    ​		0001 0010
>
>    ----
>
>    ​		1100  1010[负数 - 补码] ---> 反码: 1100 1001 --> 原码 : 1011 0110 ----> -(32+16+4+2) = -54 

## 二. 问题解决:

> 1. 32b和64b的区别
>
>    ​	表示的CPU一次性处理数据的能力 
>
>    ​	如果32位  在内存中寻址空间 2^32 ---> 4G[真实可用的空间 3.7G] ---- 
>
>    ​		32b的话计算机支持的最大内存4G[而且还到不了这个数]
>
>    ​			增加内存也无用的
>
>    ​	如果是64b的  在内存大概的容量2^64 容量是很大的  CPU处理数据会比32b快很多

# 三.今日内容

## 1.与计算机交互的方式

> 使用者与计算机交互方式有两种情况:
>
> ​	图形化界面
>
> ​		现在大众化的内容, 这种形式容易用户接受, 便于理解的
>
> ​	命令行交互
>
> ​		需要有一个控制台, 通过输入一些指令,使计算机完成对应的操作.
>
> ​		这种形式比较难理解的,也是比较难接受. 因为需要记住一些指令 

## 2.DOS命令[在命令控制台上输入的]

> 1. 切换盘符[  C  D  E  F]
>
>    ​	在控制台上输出对应的盘符: 回车即可进入  [不区分大小写]
>
>    ​		例如:  D:
>
>    ​	打开指定目录的时候
>
>    ​		此时此刻在C盘下的  但是被打开的目录在D盘下面  直接输入指令来打开的话 --- 这种操作是无效的
>
>    ​	打开路径的时候这个路径的盘符下 需要切换到对应的盘符下才可以打开
>
> 2. 打开指定目录[文件夹]
>
>     cd 目录路径
>
>    cd..  返回上一级目录
>
>    cd/ ---- 直接返回到根目录[盘符]
>
> 3.  列出指定目录下的子元素[子目录和子文件]
>
>    ​	dir
>
> 4. 创建目录
>
>    md ---->  [make directory]
>
>    可以创建单目录 也可以创建多级目录
>
>    ​	md 目录
>
>    ​	如果目录存在不会再创建 
>
> 5. 删除目录
>
>    rd ----> [remove directory]
>
>    ​	注意: 只能删除空目录
>
>    ​	删除的时候只能删除最后一级
>
> 6. 创建文件
>
>    echo 文件的内容>文件的名字
>
> 7. 删除文件
>
>    del 文件名 --  删除指定文件
>
>    ```
>    del *.*  --- 删除当前目录下的所有文件 [慎行]
>    * 通配符 
>    * 通配所有的文件名字
>    第二个* 所有后缀名
>    ```
>
> 8. 清除控制台命令
>
>    ​	cls
>
> 9. 移动文件 / 拷贝文件 [只能是操作文件 不能操作文件夹]
>
>    ​	移动: move  源文件路径  目的目录
>
>    ​	拷贝: copy 原文件路径  目的目录
>
> 10. 退出控制台
>
>     exit

## 3.Python的基本语法

### 3.1 不同字节的时候数据的取值范围[整数]

> 1个字节[8b] ----> 整数有2^8个 256个数据
>
> 数值有正负之分的
>
> ​	0111 1111 -----> 127
>
> ​	1111 1111 ------> -127
>
> ​	在-127 ~ 127之间有两个0 这两个0的标签形式:
>
> ​		0000 0000(0)
>
> ​		-127  0  127 ----> 255个数据
>
> ​		-0  规定设置为-128
>
> ​	1个字节的时候的取值范围:  -128 ~ 127  (8位)  
>
> 在python 数值的开辟的字节数8个字节
>
> 为了掩饰1个字节的状态 我是用java来掩饰
>
> ​		java 中有一个数据类型 byte ----> 在内存中开辟的空间就是1个字节
>
> 不同字节数据取值范围的公式
>
> ​	-2^(n-1)  ~  2^(n-1) - 1  [n表示的是位数]
>
> ​	1个字节的时候:  8位
>
> ​		-2^7  ~ 2 ^7-1
>
> ​	2个字节
>
> ​		-2^15 ~ 2 ^ 15 - 1
>
> 以8位:
>
> ​	128
>
> ​		 1000 0000 ---> -0 ----> -128

### 3.2 python程序的体验

> 进入python环境:
>
> ​	在控制台的指令是: py 或者 python   [python3]
>
> 退出python环境:
>
> ​	exit()
>
> 第二种体验方式:
>
> ​	使用python提供的IDLE编辑器
>
> ​	当代码多的时候如何使用IDLE?? ---> 
>
> ​		File ----> newFile --> ctrl + S 保存指定的目录下 文件的后缀名为.py ---> 写代码
>
> ​		运行这个文件有两种方式:
>
> ​				第一中方式:shell自带的方式:   Run ---> run module
>
> ​				第二种方式:  在命令行控制台上来执行的py文件
>
> ​						先切换到文件所在路径 ---> 执行命令: python 文件名.py
>
> 

### 3.3 print语句的详解

> print整体语句的格式:
>
> ​	print(values..., sep=" ", end="\n", file=sys.stdout, flush=False);
>
> 1.values
>
> ​	这个是代表要输出的内容, 内容可以输出多个, 注意每个之间使用逗号隔开
>
> 2. sep
>
>     sep是多个数据之间的分隔符 默认是空格
>
>    如果想设置其他的分割符:
>
>    ​	sep="指定分隔符"
>
> 3. end
>
>    指的是内容输出之后 结束位置的内容 默认是换行
>
> 4. file
>
>    ​	将指定的文本输入到指定的文件中 或者数据流中[sys.stdout]
>
> 5. flush
>
>    表示的是刷新 将写入文件或者数据流的达到目的地
>
>    r"D:\"
>
>    ```html
>    window的情况下 目录之间的分割符是\.. 在程序中想表示\需要使用\\来表示
>    \在程序中具有特殊的意义: 具有转义的意义  如果想保持本意的话 \\
>    	\n ----> 换行
>    	\t ----> tab 制表符
>    windows下的目录的	D:\\classContent
>    在程序中\\就相当于\
>
>    如果在程序中不想写\\的话 可以在字符串前面添加r"D:\classcontent" 整体转义
>    ```
>
>    

### 3.4 注释 -  在代码中添加自己理解

> 在写代码的时候 对有些知识点不太熟悉 需要添加的自己的标注 ---> 注释
>
> 单行注释:  #
>
> 多行注释:
>
> ​	''' 注释的内容 '''
>
> ​	或者是
>
> ​		""" 注释内容 """

### 3.5 变量

> 方程时 一元一次方程
>
> 有一个未知项参与运算  给这个位置项起一个名字 x
>
> 参与运算  计算出x的值
>
> ​	不同的情况下x代表不同的值  只要我拿到x就能获得对应的数据   x称之为变量名
>
> 数据是变化的值 ----> 变量
>
> 为了获取这些变化的数据  所以定义一个名字x 让他等于变化的数据 ----> x称之为变量名
>
> 变量的作用:
>
> ​	用于存储可变的数据的, 便于之后使用和修改, 为了方便修改, 还给这些数据添加了一个标识名[x变量名]
>
> #### 在计算机中存储数据 是在内存中
>
> ​	在内存中存储数据的时候 --- 先开辟一块空间  在这个空间中添加对应的数据
>
> 变量在内存中的意义:
>
> ​	在内存中开辟了一块空间 来存放变化的数据
>
> 在程序中定义变量, 以及定义变量的注意事项:
>
> ​	变量在使用之前一定要进行声明  和 赋予初始值
>
> 定义的格式:
>
> ​	变量名 = 数据
>
> ```python
> #变量的声明
> a = 10
> print(a) #使用的时候通过变量名来获取
> 
> #其他声明方式
> a , b = 10, 20
> print(a, b)
> ```
>
> 

### 3.6 标识符

> 在程序中自定义名称的时候 使用的名称称之为标识符
>
> 标识符的组成:
>
> ​	英文字母 数字  下划线
>
> 使用标识符来自定义名称时的注意事项:
>
> 1.不能以数字开头
>
> 2.不能使用python提供的关键字 [只要在python中 变色的就不要使用]

### 3.7 数据类型整理

> 为变量赋予不同的值的时候  就代表者这些数据有不同的类型
>
> 变量到底是什么类型的 ---> 是根据赋值来决定
>
> 常用的基本类型:
>
> ​	数值类型Number
>
> ​		int --- 整型 [值都是整数]
>
> ​		float --- 浮点型[值都是小数]
>
> ​		complex --- 复数型[不常用] --- 实部加虚部   4 + 3j
>
> ​	字符串类型
>
> ​		str
>
> ​			字符:  单个符号
>
> ​			字符串的标识'单引号或者双引号
>
> ​			"15"    "a"
>
> ​	布尔类型
>
> ​		bool
>
> ​			只有两个状态的值  True 和 False
>
> ​		严格区分大小写的
>
> ​			把True视作1  False 视作0
>
> ​			非0即为True  
>
> ​		**用数值状态来表示数值类型 只要不是0 就是True **
>
> ​		严格的情况下还是建议使用True和False
>
> ​	列表
>
> ​		list
>
> ​		容器 ---> 里面可以存放不同类型的多个数据
>
> ​		标志是[]
>
> ​	元组
>
> ​		tuple
>
> ​		容器 --- 与list的区别:  数据元素是不可变的
>
> ​		标志是()
>
> ​		如果只有一个数据 也要添加逗号(1,)
>
> ​	字典类型
>
> ​		dict
>
> ​		容器: 存放一一对应的映射关系的容器, 键值对的格式
>
> ​		标志: {key:value, key:value}
>
> ​		特点: 根据key查找value . 得保证key的唯一性
>
> ​	集合
>
> ​		set 
>
> ​		容器:  不能存在重复元素的容器
>
> ​			----> 只存放字典中key
>
> ​	特殊的值: None ----> 空的, 什么都不指向
>
> ​		**变量声明完成之后 会在内存中开辟一块地址 声明变量的时候 要赋予初始值**
>
> ​		如果这个初始值不知道赋予什么 , 就可以赋予None

### 3.8 输入的语句:input

> 格式:
>
> value  =	input("提示语")
>
> ​	小括号中是提示语, 用户输入之后 点击回车结束输入 ,  用户输入的内容会由input返回
>
> value的类型默认是**字符串**类型的
>
> 检验一个变量的类型: type(变量)

### 3.9 类型转化的方法的使用

> 1. 将指定数据转化为整型
>
>    ​	value =  int(数据)
>
>    ​	注意: 如果转化的数据是字符串类型的话  想转化成功需要保证字符串中的字符都是数值
>
> 2.  将指定数据转化 为浮点型
>
>    ​	float(数据)
>
>    ​	注意: 如果转化的数据是字符串类型的话  想转化成功需要保证字符串中的字符都是数值
>
>    ​		浮点数是可以识别小数点的  如果字符串中包含1个小数点是没有问题的
>
> 3. 将指定数据转化为字符串
>
>    str(数据)
>
> 4. 将指定数据转化为布尔类型
>
>    ​	bool(数据)
>
> 5. 将一个十进制数据转化为该数据对应的编码的字符
>
>    ​	chr(整数)  [一般整数的取值范围0-65535]
>
> 6. 获得自定字符对应的十进制数据
>
>    ​	ord(单个字符)
>
> 7. 将数据转化为二进制数据
>
>    ​	bin(数据)
>
> 8. 将对应的数据转换为十六进制的数据
>
>    ​	hex(数据)
>
> 9. 将对应的数据转换为八进制的数据
>
>    ​	oct(数据)

### 3.10 运算符

> 算术运算符
>
> ​	基础运算符	
>
> ```
> 	+
> 	-
> 	*
> 	/
> 	// : 整除
> 	** : 求幂数  x的y次方   x**y
> 	% : 取余数		x % y 的意思是:  x // y 商  余[取的这个数]
> ```
>
> ​	复合运算符
>
> ```
> 赋值运算符 =
> 加法赋值  +=:   a+=b ===> a = a + b  [一个变量在等号左右的区别: 在等号左边等待着被赋值的, 在右边的话是取变量原来的值]
> 减法赋值  -=:   a-=b ====> a = a - b
> 乘法赋值  *=:	a*=b ====> a = a * b
> 除法赋值   /=:	a /= b ====> a = a / b
> 整除赋值  //=:  a//=b ====> a = a // b
> 取余赋值   %=:	a%=b ====> a = a % b
> 求幂赋值  **=:  a**=b ====> a = a ** b
> ```
>
> 关系运算符
>
> ```
> 恒等 ==
> 不等于  !=
> 大于等于  >=
> 小于等于  <=
> 大于     >
> 小于     <
> 经过关系运算符运算之后的结果是布尔类型的  要么成立(True) 要么不成立(False)
>
> ```
>
> 逻辑运算符
>
> ```
> 逻辑运算符两边连接的是bool表达式 最终的运算结果也是bool类型的
> 逻辑与
> 	and
> 	总结: 一假则全假
> 	True and True = True
> 	False and [True/ False] = False
> 	True and False = False
> 逻辑或
> 	or
> 	总结: 一真则全真
> 		False or False = False
> 		其他的情况下为True
> 逻辑非
> 	not(表达式)
> 	真变假 假变真
> 	not(True) ---> False
> 	not(False) ---> True
> 	
> 短路原则:
> 	and:
> 		and符号的左边的表达式不成立的时候 右边的表达式不会再参与运算, 如果后面有or的话直接运行or的表达式  [and的优先级大于or的优先级] [数学中 *  -]
> 	or:
> 		or符号的左边的表达式成立的话 右边的表达式不参与运算
> 	
> 	通过and和or的短路的元素 出现三元表达式
> ```
>
> 成员运算符
>
> ```
> in
> 	在指定的序列中 找到对应的数据 返回True  否则 返回False
> not in
> 	在指定的序列中 没有找到对应的数据 返回True  否则 返回False
>
> 	除了数值 和 bool其他 这些类型之外
> ```
>
> 身份运算符
>
> ```
> is
> 	找到是变量的地址 地址一致结果为True 否则结果为False
> is not
> 	地址不一样 结果为True  否则结果为False
> ```
>
> 三元运算符
>
> ```
> 格式:   条件表达式  and  结果1  or  结果2
> 条件 表达式成立的时候 执行结果1
> 条件表达式不成立  执行结果2
>
> 注意: 三元运算符结束之后 出现的是结果  这个结果程序员是可以获取并用于其他操作的
> ```
>
> 位运算符[了解]
>
> ```
> 操作二进制数据的:  只有0和1  规定:将0视作False  将1视作True
> 以16位为例
> 按位与
> 	&
> 	上下只要有一个为0 结果就是0
> 		-8  &  9
> 按位或
> 	|
> 	上下只要有一个为1 结果就是1
> 按位异或
> 	^
> 	上下只要一样结果为0 [相同为假 不同为真]
> 	一个数与相同的数异或两次 结果是其本身
> 	练习: 交换两个变量的值
> 		num1 = 19
> 		num2 = 22
> 		 ----> 通过异或的形式进行交换 ----> num1 = 22  num2 = 19
> 		
> 		其他方式交换两个变量的值:
> 			简单粗暴:
> 				num1 , num2 = num2, num1
> 			委婉的: 借助于第三方变量:
> 				#num1 = num2; // num1 = 22
> 				#num2 = num1; // num2 = num1 = 22
> 				得提供一个变量保存一方的数据 
> 					temp = num1;  // temp = 19
> 					num1 = num2; // num1 = 22
> 					num2 = temp; // num2 = 19
> 			更残暴的方法:[难以理解]
> 				num1 = num1 ^ num2;  // 19 ^ 22
> 				num2 = num1 ^ num2;  // num2 = 19 ^ 22 ^ 22 = 19
> 				num1 = num1 ^ num2;  // num1 = 19 ^ 22 ^ 19 = 22
> 		
> 按位取反
> 	~
> 	将0变1  1变0
> 按位左移
> 	<<
> 	将二进制数向左移动指定位数 右边空出补0
> 按位右移
> 	>>
> 	将二进制数据向右移动指定位数 正数补0  负数补1
> 	
> 以上这些符号的在运算的时候 符号位是参与运算
> 这些运算时都是上下一一对应的运算关系 没有进位一说
> 都是二进制的补码的形式
> ```