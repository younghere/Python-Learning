## 一、单例模式（Singleton Pattern）

单例模式是**设计模式**之一

​	设计模式：-->算法--->前辈们总结出来解决某种问题的模式

**单例模式（Singleton Pattern）**是一种常用的软件设计模式，该模式的主要目的是确保**某一个类只有一个实例存在**。



### 1.使用模块

**Python 的模块就是天然的单例模式**，因为模块在第一次导入时，会生成 `.pyc` 文件，当第二次导入时，就会直接加载 `.pyc` 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。

```python
class User(object):
    def __init__(self, name):
        self.name = name
    #聊天
    def chat(self):
        print(self.name, "进行聊天")
    #发表朋友圈的功能
    def publish(self):
        print(self.name, "发表朋友圈")
#在模块中创建出来一个对象 --->这个对象不是在类中创建的
instance = User("小沐")

#要使用时，直接在其他文件中导入此文件中的对象，这个对象即是单例模式的对象
```

### 2.使用装饰器

装饰的类--->让这个类只能创建一个对象

​	**装饰器的形式就是一个闭包**

```python
#声明一个装饰器 -->作用：使对应的类有且仅有一个对象
def single(cls):
	#将即将创建出来的实例存在字典中：内容key:value  以cls 为key
    #为什么以cls为key ：因为创建的是一个类的实例 也就是意味着这些实例的类是同一个
    ins_dict = {}
    def wrapper(*args,**kwargs)
   		#声明对应的对象
		if cls not in ins_dict:
        	ins = cls(*args,**kwargs) #相当于 instance = User("小牧")这个步骤  ----->内部函数用 被装饰的函数 替代
    		ins_dict[cls] = ins
		return ins_dict[cls] <——————#即返回第一个对象
	return wrapper #装饰器的固定格式 最后return内部函数


@single       #调用装饰器
class User(object):
	def __init__(self,name):
		self.name = name
	def like(self):
		print(self.name,"进行点赞")
		
#添加上装饰器以后 已经执行了外部函数 并将结果赋给了与
#User = single(User)
#single(User) ---->返回的是内部函数
#User 等价于 内部函数
#执行User 就是执行内部函数

instance = User("小牧")
print(instance.name)

instance1 = User("积分卡")
print(instance1.name)

#输出结果总是   “小牧”

若要修改原对象 ：
instance.name = "小木木"

例题：清朝期间皇帝乾隆 带着 大臣和珅与纪晓岚 巡视江南
		对象:
			乾隆 -----> 皇帝类 ----> 只有一个对象 ----> 需要把皇帝类设置为单例类
```

```python
# *args表示任何多个无名参数，它是一个tuple
#**kwargs表示关键字参数，它是一个dict

def foo(*args,**kwargs):
	print 'args=',args
	print 'kwargs=',kwargs
print '**********************'
if __name__=='__main__':
foo(1,2,3)
foo(a=1,b=2,c=3)
foo(1,2,3,a=1,b=2,c=3)
foo(1,'b','c',a=1,b='b',c='c')
#输出结果为：
args= (1, 2, 3)
kwargs= {}
**********************
args= ()
kwargs= {'a': 1, 'c': 3, 'b': 2}
**********************
args= (1, 2, 3)
kwargs= {'a': 1, 'c': 3, 'b': 2}
**********************
args= (1, 'b', 'c')
kwargs= {'a': 1, 'c': 'c', 'b': 'b'}
**********************
		
```

### 3.使用类方法

不借助模块 也不借助装饰器 由类本身来完成单例的操作

简单而言：借助类方法  在类体中创建出来对应的实例

**这种形式不如装饰器严谨**：创建一个空对象的话就会默认带一个无参的

```python
class User(object):
	def __init__(self):
		pass
#声明一个类属性 -->接受该类的实例
	__instance = None
	@classmethod     #类方法
	def get_isinstance(cls):
		if cls.__instance == None:
			cls.__instance = cls()
		return cls.__instance
user1 = User.get_isinstance()
print(user1)
```

### 4.基于\__new__方法实现

```python
import threading
class Singleton(object):
    _instance_lock = threading.Lock()  #线程锁

    def __init__(self):
        pass


    def __new__(cls, *args, **kwargs):
        if not hasattr(Singleton, "_instance"):
            with Singleton._instance_lock:
                if not hasattr(Singleton, "_instance"):
                    Singleton._instance = object.__new__(cls)  
        return Singleton._instance

obj1 = Singleton()
obj2 = Singleton()
print(obj1,obj2)

def task(arg):
    obj = Singleton()   #实例化方法和平时一样
    print(obj)

for i in range(10):
    t = threading.Thread(target=task,args=[i,])
    t.start()
```

更多关于单例模式：https://www.cnblogs.com/huchong/p/8244279.html

## 二、抽象类

**有抽象方法的类叫做抽象类**

**抽象类的最大特点是：只能被继承，不能被实例化**

必须存在继承关系

父类抽取子类的共性（共同行为）

​	子类的该行为的实现功能 各不相同 --->可以抽取这个方法用来生成抽象方法【不需要填写功能】-->

**必须由子类重写**才可以

**抽象类本身是不可以在创建对象的了 必须被继承才有意义**

**抽象类中的抽象方法必须被子类实现才可以 否则报错**

```python
长方形:
	长
	宽
	行为:
		计算面积
		计算周长
圆形:
	半径
	行为:
		计算面积
		计算周长
形状类:
	行为:
		计算面积 ----> 声明成抽象方法
		计算周长  ----> 声明成抽象方法
from abc import ABCMeta, abstractmethod
#metaclass=ABCMeta 让当前类形成抽象类
class Shape(object, metaclass=ABCMeta):

    @abstractmethod # ---> 让当前方法形成抽象方法
    def length(self):
        pass

    @abstractmethod
    def area(self):
        pass
        
from abstract_pack.shape import Shape

class Rect(Shape):
    def __init__(self, width, lengths):
        self.width = width
        self.lengths = lengths

    #重写父类方法
    def length(self):
        return 2 * (self.width + self.lengths)

    def area(self):
        return self.width * self.lengths
    
from abstract_pack.shape import Shape
import math
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def length(self):
        return 2 * math.pi * self.radius

    def area(self):
        return math.pi * (self.radius ** 2)
        
from abstract_pack.rect import Rect
from abstract_pack.shape import Shape
from abstract_pack.circle import Circle

def main():
    #抽象类不能创建对象
    #s = Shape()
    '''
    TypeError: Can't instantiate abstract class 
    Shape with abstract methods area, length
    抽象类不能进行实例化
    原因: 在抽象类中有抽象方法
    为什么有抽象方法就不能实例化:
        因为抽象方法不能被直接调用 只能被子类重写
        抽象方法时没有功能实现的 ---> 所以不能被调用的
    反证法:
        假设抽象类可以进行实例化, 就可以调用对象方法,
        对象方法中有抽象方法,那么就可以直接调用抽象方法
        但是抽象方法不能被直接调用 所以假设不成立
    '''

    #创建一个子类对象
    r = Rect(12, 34)
    '''
    TypeError: Can't instantiate abstract class Rect with 
    abstract methods area, length
    Rect是Shape的子类 所以Shape可见的特征 子类都有
    '''
    print(r.area())
    print(r.length())
    
    c = Circle(10)
    print(c.area())
    print(c.length())

if __name__ == "__main__":
    main()
```



## 三、字节数据类型bytes/bytearray

是用来存放多个字节数据的

```python
#创建一个空的字节数组对象
#None ---> 这个内容在内存中是不存在
#空的对象 ----> 在内存时开辟了空间的 只不过这个空间是没有内容
#传入int类型的数据
bytes2 = bytes(10)
print(bytes2)
#传入的是一个整数, 那就表示在字节数组中开辟了10个放置元素的位置 只不过没有给每个位置赋予明确的数据 默认值0

b'\xe4\xb8\xad\xe6\x96\x87'
#b表示这是一个bytes类型数据，
#xe4表示这个十六进制数据

#gbk编码的形式 一个中文汉字占两个字节  英文符号占一个字节
#utf-8编码的话  一个中文符号占3个字节  英文符号占一个字节(unicode编码形式的一种)
#将字符串转化字节数据
bytes3 = bytes("中国", encoding="gbk")
print(bytes3)
#将字节数据转化为字符串
str2 = str(bytes3, encoding="utf-8")
print(str2, "~~~~")

#另外一种转化方式: 编码
bytes5 = "中国".encode("gbk")
print(bytes5)
#将字节数据转化为字符串: 解码  编码和解码的格式要一致
str1 = bytes5.decode("gbk")
print(str1)


```

程序员做操作的时候习惯使用的是字符串；计算机做操作的时候是用字节数据

## 四、IO输入输出机制

对文件在程序中做对应的操作

这个输入输出机制中参照物是对应的程序，将数据读取到程序，这个过程叫做输入

将程序中的数据写出到指定文件叫做输出

什么是文件？

​	文件是存储在外界设备上的数据或者信息的集合

在程序中想要打开一个文件并且对文件

打开文件的格式：

```python
file object=open(file_name[,access_mode][,buffering])
open内的参数分别为：文件路径，文件打开模式，缓冲值(若为1，则在访问一个文件进行缓冲，为0或者负数则不缓冲)
打开模式中追加参数'b'表示以二进制模式打开文件：数据会以字节对象的形式读出和写入。
文本模式下，读取数据时会修改行结束符，可能对JPEG或EXE这样的二进制文件中的数据有损坏。不要使用'b'读写

一旦文件被打开，则就会有一个文件对象，你就可以得到有关该文件的各种信息
file.closed:文件是否被关闭
file.mode:返回文件的访问模式
file.name:返回文件名    
    
fp.tell()#获取文件指针的位置    
```



```python
'''
windows系统中表示换行的是\r\n
unix系统上的换行 \n
'''

		#以二进制形式读取 不用添加编码方式
#对于图片 视频等等这些文件都是采用二进制的形式
fp = open(r"C:\Users\Administrator\Desktop\test.png", "rb")
print(fp)

#可以通过手柄读取文件中的数据
data = fp.read() # 一次性全部读出
print(data)

import os
 with open(r"C:\Users\Administrator\Desktop\test.png", "rb") as src, open("test_copy.png", "wb") as dest:
    #从源文件中读取内容
     list1 = src.readlines()
     dest.writelines(list1)
     dest.flush()
      
#文件太大的话 可以分批读取
'''
读取的终止点
文件的大小 ---> KB
    -- 分批读的时候  1KB   1024B
    记录这个累计量 ----> 与文件大小
'''

#以1024字节大小依次打开大文件
path = r"D:\迅雷下载\素媛.mkv"
file_size = os.path.getsize(path) #文件大小
print(file_size)
read = 0
with open(r"D:\迅雷下载\素媛.mkv", "rb") as source, open("copy_video.mkv", "wb") as aim:
    while read < file_size:
        data = source.read(1024)
        aim.write(data)
        aim.flush()
        read += 1024
```

打开模式：

​	打开模式:

​	r --- 只读

​	w ---- 只写  如果该文件不存在会新建的一个的

​			如果文件存在的话 会将文件中的数据覆盖 将内容写入

​	x - 很少

​	a -  只写  如果文件存在的话 会将新内容拼接在原有内容的后面

​	r+  ---- 读写

​	w+

​	x+

​	a+  -----> 写读

​	***带有b的话 是二进制模式：***

​	rb ----> 二进制只读

​	wb ---> 二进制只写

​	既带有b又带有+

​		rb+  ---- 二进制读写

​		wb+ --- 二进制写读

​		ab+ --- 二进制写读追加模式



1.读取文件

```python
read([size])            
	---如果不写参数的话 表示一次性全部读取
	如果设置了size 就读取size个字节
readline()
	---一行一行的读取
readlines()
	---这个方法返回的是一个列表 列表中的元素是 一行一行的内容
data = fp.seek(2)--表示指针移动到某字节位置
		#读取完fp.close() 关闭文件

    
#对于二进制文件，比如图片、视频等等，用'rb‘模式打开文件即可
>>> f = open('/Users/michael/test.jpg', 'rb')
>>> f.read()
'\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...' # 十六进制表示的字节

#对于字符编码
要读取非ASCII编码的文本文件，就必须以二进制模式打开，再解码。比如GBK编码的文件：
>>> f = open('/Users/michael/gbk.txt', 'rb')
>>> u = f.read().decode('gbk')
>>> u
u'\u6d4b\u8bd5'

#如果嫌每次手动转换编码麻烦，python提供了codecs模块，直接读取Unicode
import codecs
with codecs.open('/Users/michael/gbk.txt', 'r', 'gbk') as f:
    f.read() # u'\u6d4b\u8bd5'

   
with open("test.txt", "w", encoding="utf-8") as f:
    #写的方法
    f.write("你好")
    #另一种写的方式
    f.writelines("\n我好\n大家好") #一行一行的写
   
  #可以写入一个列表[主要目的] ----> 这个方法是来配合readlines使用
    f.writelines(["11", "12", "13"])
    #写完之后刷新
    f.flush()

```

csv文件 逗号分隔文件格式  解读这种格式的文件 需要导入csv模块

**序列化**：变量从内存中变成可存储或传输的过程`json.dumps()`

**反序列化**:变量内容从序列化的对象重新读到内存里的过程 `json.loads()`

反序列化得到的所有字符串对象默认都是`unicode`而不是`str`。由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的`str`或`unicode`与JSON的字符串之间转换。

```python
import pickle
whith open("save.txt","wb") as f:
	pickle.dump(list0,f)
with open("save.txt","rb) as f:
	data = pickle.load(f)
	print(data)
	#应用场景：
		#大多数数据库：用于存放大型数据的
		#小型的数据就可以存放本地文件中
import csv
with open("000001.csv", "r", encoding="gbk") as fp:
    allinfo = csv.reader(fp)
    print(allinfo)
    for row in allinfo:
        print(row)
        print(type(row))
```

json格式对文件进行序列化

```python
#将对象序列化
def student2dict(std):
    return {
        'name': std.name,
        'age': std.age,
        'score': std.score
    }

print(json.dumps(s, default=student2dict))#default参数
#当对象不断变化时
print(jsson.dumps(s,default=lambda obj:obj.__dict__))

#反序列化
def dict2student(d):
    return Student(d['name'], d['age'], d['score'])

json_str = '{"age": 20, "score": 88, "name": "Bob"}'
print(json.loads(json_str, object_hook=dict2student)) #object_hook参数
```

