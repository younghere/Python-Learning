求1 -100内的质数的和：

```python
num = int(input("请输入一个数字"))
isprime = True
for i in range(2,num):
	if num % i == 0:
      print(num,”不是质数“)
		isprime = False
		break
if isprime == True：
	print(num,"不是质数")
```



## 一、函数

### 1.函数的概述：

方法：

将代码进行封装，当使用的时候调用函数，

封装成函数的好处：如果要改动内容，改变一次即可，这样的话不仅提高代码的封装性，还提高了程序的执行效率，降低了代码的冗余。

### 2.函数的分类：

内置函数和自定义函数

内置函数：

​	python 提供的可以直接使用的方法：

​		例如：print() input() help() type()

自定义函数：

​	函数是有一个函数名的：根据自己的需求封装好的功能

​	**函数名命名规范**：每个单词都是小写的 单词和单词之间使用下划线隔开

​		例如：rangdom_randint

### 3.函数的声明：

函数的声明格式[语法]： 

​	**def 函数名(变量名1，变量名2，……)**

**		函数体**

**		return 函数运行的结果**

return：结束函数 将结果返回给调用者

**有些方法是不需要返回结果的，可以省略return 或者直接一个return即可**

形参和实参：

​	**形参**：声明函数时，接受参与函数运算的未知数的变量

​	**实参**：调用者传递给形参的数据

声明函数时两个准则：

​	1.明确函数中是否有未知项参与运算

​		---->可以决定声明函数的时候没有形参

​			如果

​	2.**明确调用者是否需要函数运行的结果**

​	---->可以决定是否有return语句

函数声明的练习：

```python
def compare(a,b):
    return  a == b and True or  False #超简洁的选择方式
print( compare(1,2))
```

```python
 def circle_area(radius):
	s = 3.14 * radius ** 2
	return s
  circle_area(4)#调用该函数
  
# i = int(input("请输入一个行数："))
def n_mut(i):
    for c in range(1,i + 1):
        for j in range(1,c + 1):
            print(c,"*",j,"=",c * j,end=", ")
        print()

n_mut()#调用该函数
```

**函数的调用：**

​	**函数名(实参)**

​	如果声明的时候没有形参 实参就不用写

```python
#判定闰年和平年以及每月有多少天
def pandingnian(year):
    if year % 4 == 0 and year % 100 != 0 or year % 400 == 0:
       return True
    else:
        return False
def pandingyue(year,month):
    if month in(1,3,5,7,8,10,12):
        return 31
    elif month in (4,6,9,11):
        return 30
    return pandingnian(year) and 29 or 28#调用pandingnian(year)自定义模块
year = int(input("请输入年份："))
month = int(input("请输入月份："))
if pandingnian(year) == True:
    print(year,"年是闰年,",month,"月有",pandingyue(year,month),"天",sep="")
else:
    print(year, "年是平年,", month, "月有", pandingyue(year, month), "天",sep="")
```

#### 函数的执行流程

**方法压栈**

栈 --- 内存结构

在程序中执行的任何内容都是在内存中

类比:  内存 ------> 房子

房子:

​	卧室

​	客厅

​	卫生间

​	厨房

内存中分为了不同的区域:

> ​	****栈****

> ​		----> 存放的是**被执行的函数**

> ​		特点: **先进后出** [可以把它看做是向上开口的容器]

> ​			**释放内存**:  当函数执行完  其所占的内存地址就被释放

> ​	****堆****

> ​		----> 放到的是对象

> ​	****方法区****:

​		---> 共享区域[相当于客厅部分]

​			****常量池****

​				固定的数据

​				a = 10

​				s = "abc"

​			****静态池****

​				

​			****方法池****

​				声明的方法存放在方法池中

​				当方法被调用的时候  拷贝到栈中一份 去执行

​	本地方法区

​	寄存器

### 4.作用域：

​	形参只在函数体中才有用，即是函数名一样，代表的也不相同

### 5.匿名函数：

**lambda 函数名 ：函数体**

**f = lambda  multply : x * y**

**res = f(5，6)**

**print(res)**

### 6.递归函数（recursion)

递归函数的特点：

1. 一个函数在内部调用自身
2. 必须有一个递归结束条件，称为递归出口
3. 递归在python中的最大深度997层

```python
#递归遍历目录和文件
import os
def dirlist(path)：
	if not os.path.exists(path):
        print('该路径不存在')
       	break
    
    if os.path.isfile(path):
        print(path)
        break
        
    listdir=os.path.listdir(path)
    for i in listdir:
        joinPath=os.path.join(path,i)
        if os.path.isfile(joinPath):
            print(joinPath)
        elif os.path.isdir(joinPath):
            dirlist(joinPath)
            
#递归算出阶乘
def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
```

在计算机中，函数调用是通过栈(stack)这种数据结构来实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限制的，所以，递归调用的次数过多，就会导致**栈溢出**。

解决递归调用栈溢出的方法是通过**尾递归优化**

**尾递归**是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

```python
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
```

可惜的是Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。

### 7.偏函数：

**偏函数类似于设定默认值**

int这个函数 强转其他类型为整型

**res = int("12323",base = 2)  #在2进制的基础上强转为10进制**

**def int_cut(content,base = 2):**

​	**return int(content,base)**

**import functools**

**int2 = functools.partial(int,base = 2)**   # 借助partial这个方法 把系统方法改进一下，将原先默认值设置为新值

### 8.默认参数：

print（values，sep=" ",end="")

自定义参数中也可以设置默认参数

def mulpity (x ,y = 4)   #自定义y = 4为默认参数

​	res = x * y

​	return res

### 9.可变参数：

### 10.关键字参数：

### 11.函数的其他使用：

​	**函数可以当做一个值给变量赋值**

​	a = 10

​	函数也可以这种操作

**将一个函数赋予给另外一个变量，该变量具有该函数的功能**

def add(a,b):

​	return a + b

f = add

res =f(34,2)

print(res)

**不要加小括号，加上小括号表示的是函数的调用，**



**函数回调---把函数当做另一个函数的参数**

**函数可以被当做一个值被传递**



