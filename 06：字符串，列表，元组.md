## 1、字符串续集

**字符串数据一旦生成是不可变的**

即：字符串是不允许直接增删改的

```python
'''格式化字符串
    格式化符号 : 元素占位符
        %s -----> 对象
        %d ----> 整数
            2018-04-01
            %0nd ----> 整数有多少位 n就为多少即可
                %02d
        %f -----> 浮点数
            保留多少位小数
                %.nf 
                    ----> n表示的是保留小数的位数
晓明的生日是2000-05-12, 考试成绩是87.553[保留一位小数], 是否婚配:False 
'''
a = "%s的学校是%s,生日是1994-%2d-%02d,初试成绩为%.2f,是否婚配:%s" %("李磊","华北科技学院",10,9,45.662,False)
print(a)

s = r"D:\ClassContent\BJ_Python1805\day05\notes"

#获取倒数第一个字符
l=s[-1]

#字符串拼接
l=s + 'asdsdf'

#字符串乘积
l=s *3

#获取字符串长度
l = len(s)
print(l)
#取脚标 [0, len(s)-1]

#将小写字母转化为大写
upper_s = s.upper()
print(upper_s)

#将大写字母转化为小写字母
lower_s = s.lower()
print(lower_s)

#将大写字母转化为小写字母 小写字母转化为大写字母
trans_s = s.swapcase()
print(trans_s)

s = "hello Good Nice BEAUTY 你好"
#将首字母转化为大写 其他都是小写
cap_s = s.capitalize()
print(cap_s)

#查找子串
# index -- 从左向右找 如果找到返回对应的索引位置,找不到报错
res = s.index("Good")
print(res)

#指定从某个位置开始找
res = s.index("Good", 7)
print(res)

#find  找到返回对应的位置 找不到返回-1
res = s.find("Good", 7)
print(res)  #-1

# 从左向右找最后一次出现的位置
# 从某个位置开始
res = s.rfind("e", 15)
print(res)

#切割字符串
s = "hello nice to meet you"
#指定一个切割符 以这个切割符为切点 将原串切为几分  最终使用列表保存切割出来的这几份

strs = s.split("e")
print(strs)

#去除字符串两端指定字符
s = "efef     abc    abc    abc      efef"
strip_s = s.strip("ef")   #被去除字符必须在最外边
print(strip_s)

#只去除左端
left_s = s.lstrip("ef")
print(left_s)

#之去除右端
right_s = s.rstrip("ef")
print(right_s)

#将以空格分隔的每个单词的首字母大写，其他字母小写
title_s = s.title()

#获得该字符在字符串中出现的次数
count = s.count("o")
#传的索引的位置都是从0 开始的
count = s.count("o",2,8)

#制定一个字符宽度 让内容居中
center_s = s.center(40)

#使当前文本居中 使用其它字符填充空白字符
center_s = s.center(40,"~")

#左对齐
left_s = s.ljust(40,"*")

#右对齐
right_s = s.rjust(40,"@")

#替换字符串
replace_s = s.replace(“老字符”，“新字符”，1)#数字表示替换多少个，默认全部替换
#替换也可以当删除使用
replace_s=s.replace('a','')

#拼接字符串[拼接的是序列中的字符串] 
"字符".join(string) 
        b = "A".join("hjh")  
        print(b)
        结果是：hAjAh
```

## 2.列表List

列表表示的是一种有序的集合[有序：加入顺序和显示出来的顺序是一致的]

可以随时增加元素、删除元素、修改元素等等的操作

在列表中可以添加任意类型的数据[建议：统一类型的数据]

添加到列表中的元素会自动为其添加编码，编码的序号是从0开始的

​	{43,53,254,5434,}   叫做集合       集合是无序的

​	{"语文"：89，“数学”:90}      叫做字典

```python
list1 = [2,34,5,6,23,5,3]

#获取列表的长度
length =len(list1)

#获取列表中的元素：根据脚标获取
#如果索引>最大索引值（无论正负） 会报越界的错误
ele = list1[5]

#修改指定位置的元素
list1[1] = 34
print(list1)

#添加元素
#在末尾追加元素
list1.append(49)
print list1

#在指定位置添加元素
list1.insert(4,354)#在4号脚标位置添加354，后续元素向后挪动一位

#还可以添加列表
other_list = [23,53,6,7,9,2]
list1.extend(other_list)

#若两个列表相加 是生成新的列表，不是在原列表添加

#将自身元素重复n遍
n_list = list1 * 2

#删除末尾元素
list1.pop()

#删除指定位置的元素
list1.pop(2)

#删除第一次出现的指定元素
list1.remove(77)

#获取重复元素出现的个数
count = list1.count(77)

#删除列表中的重复元素，留下一个(原理是：先转化为集合，再转化为列表)
a = set(list1)
b=list(a)
print(b)

#获取某个元素第一次出现的位置
index = list1.index(77)#找到返回对应的位置，找不到报错

#切片：提取子列表
sub_list = list1[::-1]

sub_list = list1[0:len(list1):2]

#将列表元素倒序,影响的是原列表
list1.reverse()

#清除列表元素
list1.clear()

#浅拷贝叫做引用拷贝
list_1 = [1,2,4,5]
list_2 = list_1
#list_2 的引用地址与list_1的地址是一样的

#深拷贝叫做内存的拷贝
list_3 = [2k,5,3,5,6]
list_4 = list_3.copy()

#特殊的情况 深拷贝的时候 元素中有一个对象的存在 是指向其他地址的
list_0 = [53,53]
list_5 = [3,4,1,list_0]#list_0是浅拷贝
list_6 = list_5.copy()
#操作
list_6[3][0] = 8 #表示更改list_0中数据
#list_5中

#二维列表
	#列表中的元素是列表
  #ll = [[],[]]
  ll =[[1,2,4],[5.6,8]]
  #从ll中拿到4：
  ls = ll[0][2]
 
#排序的方法：
          list2 = [2,6,8,1,0]
          升序：
          list2.sort()
          降序：
          list2.sort(reverse = True)
          list3 =["abc","vsd","jkd","dfsf"]
          #字符串比较的每个字符的对应的十进制数据
          #如果多种字符进行比较，abc 和 adc 先比较第一个
          def sort(self,key=None,reverse=False)
          reverse控制的是升序还是降序
          key 接收的是函数
  
#常见的操作
  	遍历列表
    	#元素遍历
      	list0 = [33,4,3,7,8,90]
        for i in list0
        	print(i)
      	#根据索引值遍历:索引值从0开始
        for index in range(0,len(list0):
            print(list0[index])
         #枚举遍历
          	for index，i in enumerate(list0):
               print(index,"-",i)
               #既能获取索引 又能获取元素值
               #替换range 因为它没有enumerate运行效率高
#获取最值：
     max_value = list0[0]
     for i in list0:
         if i > max_value:
              max_value = i
     print(max_value)
#另一种方法：
 	比较脚标对应的元素的大小
     max_index = 0
     for index in range(len(list0)):
      	if list0[index] > list0[max_index]:
            max_index = index
     print(list0[max_index])
```

排序：

1. **range(0,len(list))是表示依据被比较的数的索引位置**来排序

2. **range(len(list))一般依据比较的轮数或者次数**来排序

```python
#选择排序
#方法一：
'''
第一次：脚标为0的数和之后的每一个元素进行比较，拿到最小值
第二次：脚标为1的数和之后的每一个元素进行比较，拿到最小值
。。。
'''
def select_sort(list0):
    for out in range(0,len(list0)-1): #每轮从哪个位置开始比较
        for inner in range(out,len(list0)):#求每轮比较次数关于out的方程及比较顺序(正序)
            if list0[out] < list0[inner]:#如何比较，某个数和后面所有数相比较
                list0[out],list0[inner]=list0[inner],list0[out]
	return list0
#方法二：
'''
获取最值索引
'''
def select_sort(list1):
    for out in range(0,len(list1)-1):
        min_index=out #假设固定脚标对应的元素是最小值
        for inner in range(out + 1,len(list1)):
            if list1[inner]<list1[min_index]:
                #记录该索引位置
                min_index=inner
		#遍历完成之后，最小索引位置被记录下来，将其对应的元素，与固定脚标对应的元素交换
        list1[out],list1[min_index]=list1[min_index],list1[out]
	return list1
        
#冒泡排序
'''
第一次：脚标为0的数和脚标为1的数进行比较，换位置；脚标为1的和脚标为2的数进行比较，换位置；脚标为2的数和脚标为3的数进行比较，换位置，。。。取出一个最大值，(每轮少一个数)
第二次：脚标为0的数和脚标为1的数进行比较，换位置；脚标为1的和脚标为2的数进行比较，换位置。。。取出一个最大值
。。。
'''
def bubble_sort(list0):
    for out in range(len(list0)-1):#比较的轮数
        for inner in range(len(list0)-out-1)： #每遍历一次少一个最值元素，每轮比较的次数以及比较的顺序(正序)
        	if list0[inner]>list0[inner +1]:#如何比较，相邻的两个数进行比较
                list0[inner],list0[inner+1]=list0[inner+1],list0[inner]
	return list0

#插入排序
'''
第一次：脚标为1的数和脚标为0的数比，换位置
第二次：脚标为2的数和脚标为1的数比，换位置;脚本为1的数为脚标为0的数比，换位置
第三次：脚标为3的数和脚标为2的数比，换位置；脚标为2的数和脚标为1的数比，换位置；脚标为1的数为脚标为0的数比，换位置
。。。
'''
def insert_sort(list0):
    for out in range(1,len(list0)):#每轮从哪个位置开始比较
        for inner in range(out,0,-1):##求每轮比较次数关于out的方程及比较顺序(倒序)
            if list0[inner] >list0[inner-1]:#如何比，后面与前面的相邻数比较
                list0[inner],list0[inner-1]=list0[inner-1],list0[inner]
            else:
                #部分排序已经排好，不用再排
                break
     return list0
```

## 3.元组tuple

**如果元祖中只有一个元素，需要在这个元素后面加上逗号**

否则识别为数学运算中强调运算优先级的作用

```python
#切片等都和列表的操作相似
#元组和字符串一样是不支持增删改的

list0 =[12,25]
tuple1 =(3,5,list0)#没改变list0的地址
tuple1[2][1] = 24
#这个操作是可以的
tuple1[2] = [11,23,45]#这个操作是不可以的
```

